{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "a55c6e4d82cad380b8cebb62285c516f",
     "grade": false,
     "grade_id": "cell-11e6289c84816863",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "# Assignment 4\n",
    "\n",
    "In this assignment, we will explore countmin sketches and bloom filters. We will use two text files `great-gatsby-fitzgerald.txt` and `war-and-peace-tolstoy.txt` to load up the text of two famous novels courtesy of Project Guttenberg. \n",
    "\n",
    "We will explore two tasks:\n",
    "  - Counting the frequency of words of length 5 or more in both novels using a count-min sketch \n",
    "  - Using a bloom filter to approximately count how many words in the War and Peace novel already appears in the Great Gatsby."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "f7a2a9b0f0fe586464a31d8e4ecda728",
     "grade": false,
     "grade_id": "cell-dfc8e09426234a08",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## Step 1:  Making a Universal Hash Family (Already Done For You)\n",
    "\n",
    "We will use a family of hash function that first starts by (a) generating a random prime number $p$ (we will use the Miller-Rabin primality test for this purpopse); (b) generating random numbers a, b between 2 and p-1.\n",
    "\n",
    "The hash function $h_{a,b,p} (n) = (an + b) \\mod p$. \n",
    "\n",
    "Note that this function will be between 0 and p-1. We will need to also make sure to take the hash value modulo $m$ where $m$ is the size of the hashtable.\n",
    "\n",
    "To hash strings, we will first use python's inbuilt hash function and then use $h_{a,b,p}$ on the result.\n",
    "\n",
    "As a first step, we will generate a random prime number.\n",
    "\n",
    "### (A) Generate Random Prime Numbers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "655633cc8179edf1da08316324a305a5",
     "grade": false,
     "grade_id": "cell-29b403a91ab960c0",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "All primes smaller than 100: \n",
      "2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 "
     ]
    }
   ],
   "source": [
    "# Python3 program Miller-Rabin randomized primality test\n",
    "# Copied from geeksforgeeks: https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/\n",
    "import random \n",
    "\n",
    "# Utility function to do \n",
    "# modular exponentiation. \n",
    "# It returns (x^y) % p \n",
    "def power(x, y, p): \n",
    "\t\n",
    "\t# Initialize result \n",
    "\tres = 1; \n",
    "\t\n",
    "\t# Update x if it is more than or \n",
    "\t# equal to p \n",
    "\tx = x % p; \n",
    "\twhile (y > 0): \n",
    "\t\t\n",
    "\t\t# If y is odd, multiply \n",
    "\t\t# x with result \n",
    "\t\tif (y & 1): \n",
    "\t\t\tres = (res * x) % p; \n",
    "\n",
    "\t\t# y must be even now \n",
    "\t\ty = y>>1; # y = y/2 \n",
    "\t\tx = (x * x) % p; \n",
    "\t\n",
    "\treturn res; \n",
    "\n",
    "# This function is called \n",
    "# for all k trials. It returns \n",
    "# false if n is composite and \n",
    "# returns false if n is \n",
    "# probably prime. d is an odd \n",
    "# number such that d*2<sup>r</sup> = n-1 \n",
    "# for some r >= 1 \n",
    "def miillerTest(d, n): \n",
    "\t\n",
    "\t# Pick a random number in [2..n-2] \n",
    "\t# Corner cases make sure that n > 4 \n",
    "\ta = 2 + random.randint(1, n - 4); \n",
    "\n",
    "\t# Compute a^d % n \n",
    "\tx = power(a, d, n); \n",
    "\n",
    "\tif (x == 1 or x == n - 1): \n",
    "\t\treturn True; \n",
    "\n",
    "\t# Keep squaring x while one \n",
    "\t# of the following doesn't \n",
    "\t# happen \n",
    "\t# (i) d does not reach n-1 \n",
    "\t# (ii) (x^2) % n is not 1 \n",
    "\t# (iii) (x^2) % n is not n-1 \n",
    "\twhile (d != n - 1): \n",
    "\t\tx = (x * x) % n; \n",
    "\t\td *= 2; \n",
    "\n",
    "\t\tif (x == 1): \n",
    "\t\t\treturn False; \n",
    "\t\tif (x == n - 1): \n",
    "\t\t\treturn True; \n",
    "\n",
    "\t# Return composite \n",
    "\treturn False; \n",
    "\n",
    "# It returns false if n is \n",
    "# composite and returns true if n \n",
    "# is probably prime. k is an \n",
    "# input parameter that determines \n",
    "# accuracy level. Higher value of \n",
    "# k indicates more accuracy. \n",
    "def isPrime( n, k): \n",
    "\t\n",
    "\t# Corner cases \n",
    "\tif (n <= 1 or n == 4): \n",
    "\t\treturn False; \n",
    "\tif (n <= 3): \n",
    "\t\treturn True; \n",
    "\n",
    "\t# Find r such that n = \n",
    "\t# 2^d * r + 1 for some r >= 1 \n",
    "\td = n - 1; \n",
    "\twhile (d % 2 == 0): \n",
    "\t\td //= 2; \n",
    "\n",
    "\t# Iterate given nber of 'k' times \n",
    "\tfor i in range(k): \n",
    "\t\tif (miillerTest(d, n) == False): \n",
    "\t\t\treturn False; \n",
    "\n",
    "\treturn True; \n",
    "\n",
    "# Driver Code \n",
    "# Number of iterations \n",
    "k = 4; \n",
    "\n",
    "print(\"All primes smaller than 100: \"); \n",
    "for n in range(1,100): \n",
    "\tif (isPrime(n, k)): \n",
    "\t\tprint(n , end=\" \"); \n",
    "\n",
    "# This code is contributed by mits (see citation above)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "8ac8a3f52da6274beeda7e3ec8bbeac1",
     "grade": false,
     "grade_id": "cell-73221461b19b5567",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Step 2: Universal Hash Families\n",
    "\n",
    "We will provide three useful functions for you:\n",
    "\n",
    "  - `get_random_hash_function`: Generate triple of numbers `(p, a, b)` at random, where p is  prime, a and b are numbers between 2 and p-1. The hash function $h_{p,a,b}(n)$ is given by $ (an + b) \\mod p$.\n",
    "  \n",
    "  - `hashfun`: apply the random hash function on a number `num`.\n",
    "  - `hash_string`: apply the hash function on a string `hstr`. Note that the result is between 0 and p-1. If your hash table has size `m`, you should take a `mod m` on this result where you call `hash_string`.\n",
    "  \n",
    "  Please use these functions in your code below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "ef7c5ab31c424ee21d9a1c3b81ff2fd8",
     "grade": false,
     "grade_id": "cell-1c9654f9fcd91883",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# Get a random triple (p, a, b) where p is prime and a,b are numbers betweeen 2 and p-1\n",
    "def get_random_hash_function():\n",
    "    n = random.getrandbits(64)\n",
    "    if n < 0: \n",
    "        n = -n \n",
    "    if n % 2 == 0:\n",
    "        n = n + 1\n",
    "    while not isPrime(n, 20):\n",
    "        n = n + 1\n",
    "    a = random.randint(2, n-1)\n",
    "    b = random.randint(2, n-1)\n",
    "    return (n, a, b)\n",
    "\n",
    "# hash function fora number\n",
    "def hashfun(hfun_rep, num):\n",
    "    (p, a, b) = hfun_rep\n",
    "    return (a * num + b) % p\n",
    "\n",
    "# hash function for a string.\n",
    "def hash_string(hfun_rep, hstr):\n",
    "    n = hash(hstr)\n",
    "    return hashfun(hfun_rep, n)    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "575e46059b43af6f541a7c5e74e6e956",
     "grade": false,
     "grade_id": "cell-f383acfe5e19ce49",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## Step 3: Loading Data\n",
    "\n",
    "We are going to load two files `great-gatsby-fitzgerald.txt` and `war-and-peace-tolstoy.txt` to load up the text of two famous novels courtesy of Project Guttenberg. We will filter all wordsd of length >= 5 and also count the frequency of each word in a dictionary. This will be fast because it is going to use highly optimized hashtable (dictionaries) built into python."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "012317538b0b54757a490f1ebcf19045",
     "grade": false,
     "grade_id": "cell-22b93e681d415b67",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "21342\n",
      "8849\n"
     ]
    }
   ],
   "source": [
    "# Let us load the \"Great Gatsby\" novel and extract all words of length 5 or more\n",
    "filename = 'great-gatsby-fitzgerald.txt'\n",
    "file = open (filename,'r')\n",
    "txt = file.read()\n",
    "txt = txt.replace('\\n',' ')\n",
    "words= txt.split(' ')\n",
    "longer_words_gg = list(filter(lambda s: len(s) >= 5, words))\n",
    "print(len(longer_words_gg))\n",
    "# Let us count the precise word frequencies\n",
    "word_freq_gg = {}\n",
    "for elt in longer_words_gg:\n",
    "    if elt in word_freq_gg:\n",
    "        word_freq_gg[elt] += 1\n",
    "    else:\n",
    "        word_freq_gg[elt] = 1\n",
    "print(len(word_freq_gg))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "1be2b84b70b54d25daae840d3c5a007a",
     "grade": false,
     "grade_id": "cell-ad7310bc2a593322",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "237611\n",
      "38777\n"
     ]
    }
   ],
   "source": [
    "# Let us load the \"War and Peace\" novel by Tolstoy translation and extract all words of length 5 or more\n",
    "filename = 'war-and-peace-tolstoy.txt'\n",
    "file = open (filename,'r')\n",
    "txt = file.read()\n",
    "txt = txt.replace('\\n',' ')\n",
    "words= txt.split(' ')\n",
    "longer_words_wp = list(filter(lambda s: len(s) >= 5, words))\n",
    "print(len(longer_words_wp))\n",
    "word_freq_wp = {}\n",
    "for elt in longer_words_wp:\n",
    "    if elt in word_freq_wp:\n",
    "        word_freq_wp[elt] += 1\n",
    "    else:\n",
    "        word_freq_wp[elt] = 1\n",
    "print(len(word_freq_wp))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "56e7a5e610cd3780396524e82e81003c",
     "grade": false,
     "grade_id": "cell-4a80bf43ea35608c",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## Problem 1: Implement count-min sketch\n",
    "\n",
    "Implement `CountMinSketch` class below where `num_counters` is the number of counters.  You are given the constructor that already generates a random representative of a hash function family. Implement the functions:\n",
    "  - `increment`\n",
    "  - `approximateCount`.\n",
    "  \n",
    "Please read the constructor carefully: it initializes the counters and generates the hash function for you.\n",
    "Also, when you call `hash_string` function defined previously, do not forget to take result modulo m."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "031189883fee31a6a51def4aff506813",
     "grade": false,
     "grade_id": "cell-4f9b9b03abdcfe40",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# Class for implementing a count min sketch \"single bank\" of counters\n",
    "class CountMinSketch:\n",
    "    # Initialize with `num_counters`\n",
    "    def __init__ (self, num_counters):\n",
    "        self.m = num_counters\n",
    "        self.hash_fun_rep = get_random_hash_function()\n",
    "        self.counters = [0]*self.m\n",
    "    \n",
    "    # your code here\n",
    "\n",
    "    # function: increment \n",
    "    # given a word, increment its count in the countmin sketch\n",
    "    def increment(self, word):\n",
    "        # your code here\n",
    "        index = hash_string(self.hash_fun_rep, word) % self.m\n",
    "        self.counters[index] = self.counters[index] + 1\n",
    "        \n",
    "        \n",
    "    # function: approximateCount\n",
    "    # Given a word, get its approximate count\n",
    "    def approximateCount(self, word):\n",
    "        # your code here \n",
    "        index = hash_string(self.hash_fun_rep, word) % self.m\n",
    "        return self.counters[index]\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "e86661497abeaf155d311f90314b2c50",
     "grade": false,
     "grade_id": "cell-52b69c2c1b76f6a8",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "# We will now implement the algorithm for a bank of k counters\n",
    "\n",
    "# Initialize k different counters\n",
    "def initialize_k_counters(k, m): \n",
    "    return [CountMinSketch(m) for i in range(k)]\n",
    "\n",
    "# Function increment_counters\n",
    "# increment each of the individual counters with the word\n",
    "def increment_counters(count_min_sketches, word):\n",
    "    # your code here\n",
    "    for cms in count_min_sketches:\n",
    "        cms.increment(word)\n",
    "    \n",
    "        \n",
    "# Function: approximate_count\n",
    "# Get the approximate count by querying each counter bank and taking the minimum\n",
    "def approximate_count(count_min_sketches, word):\n",
    "    return min([cms.approximateCount(word) for cms in count_min_sketches])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "9092f909c1bde4f0b80c67144ace3e49",
     "grade": true,
     "grade_id": "cell-f46918d88bcfc44c",
     "locked": true,
     "points": 10,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Passed all tests: 10 points\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "\n",
    "%matplotlib inline\n",
    "from matplotlib import pyplot as plt \n",
    "\n",
    "# Let's see how well your solution performs for the Great Gatsby words\n",
    "cms_list = initialize_k_counters(5, 1000)\n",
    "for word in longer_words_gg:\n",
    "    increment_counters(cms_list, word)\n",
    "\n",
    "discrepencies = []\n",
    "for word in longer_words_gg:\n",
    "    l = approximate_count(cms_list, word)\n",
    "    r = word_freq_gg[word]\n",
    "    assert ( l >= r)\n",
    "    discrepencies.append( l-r )\n",
    "    \n",
    "plt.hist(discrepencies)\n",
    "\n",
    "assert(max(discrepencies) <= 200), 'The largest discrepency must be definitely less than 200 with high probability. Please check your implementation'\n",
    "print('Passed all tests: 10 points')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "f5f9d0e915170f181348ff78d61fac1f",
     "grade": true,
     "grade_id": "cell-592d2f3552e20599",
     "locked": true,
     "points": 5,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Passed all tests: 5 points\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Let's see how well your solution performs for the War and Peace\n",
    "cms_list = initialize_k_counters(5, 5000)\n",
    "for word in longer_words_wp:\n",
    "    increment_counters(cms_list, word)\n",
    "\n",
    "discrepencies = []\n",
    "for word in longer_words_wp:\n",
    "    l = approximate_count(cms_list, word)\n",
    "    r = word_freq_wp[word]\n",
    "    assert ( l >= r)\n",
    "    discrepencies.append( l-r )\n",
    "\n",
    "plt.hist(discrepencies)\n",
    "print('Passed all tests: 5 points')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "695a620d4ee55c5fa4aa7da9ff06e626",
     "grade": false,
     "grade_id": "cell-05bbe5025159958a",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "### Problem 1B\n",
    "\n",
    "Check the data obtained above with calculations along the lines of what was done in class. If we had\n",
    "$5$ banks of counters  with $5000$ counters each and a uniform hash function family, what is the probability that when counting a total of $N = 2.5\\times 10^{5}$ words, we have a discrepency by 80 or more.\n",
    "\n",
    "This problem will not be graded but simply for you to understand the calculations involved."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "be6067bdf327e5f738dbffa50c9ce755",
     "grade": true,
     "grade_id": "cell-8a8072c81e421aee",
     "locked": false,
     "points": 0,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "source": [
    "YOUR ANSWER HERE"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "47928f051cd28ea645c638e167be3b44",
     "grade": false,
     "grade_id": "cell-344a83e8908d1faf",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## Problem 2: Using a Bloom Filter to Count Common Words.\n",
    "\n",
    "In this problem, we will implement a Bloom filter to count how many elements of `longer_words_wp` (the words of length 5 or more in War and Peace) appear in the Great-Gatsby novel.  To do so, we will do the following:\n",
    " - Instantiate a Bloom filter with number of bits `n` and number of hash functions `k`.\n",
    " - Insert all words from great-gatsby into the filter.\n",
    " - For each word from war and peace, check membership in the Bloom filter and count the number of yes answers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "8ddf045e806dbb4e195888e8cd87d73a",
     "grade": false,
     "grade_id": "cell-fae86832b7a1eb5e",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "outputs": [],
   "source": [
    "class BloomFilter:\n",
    "    def __init__(self, nbits, nhash):\n",
    "        self.bits = [False]*nbits # Initialize all bits to fals\n",
    "        self.m = nbits\n",
    "        self.k = nhash\n",
    "        # get k randdom hash functions\n",
    "        self.hash_fun_reps = [get_random_hash_function() for i in range(self.k)]\n",
    "    \n",
    "    # Function to insert a word in a Bloom filter.\n",
    "    def insert(self, word):\n",
    "        # your code here\n",
    "        for i, hash_fn in enumerate(self.hash_fun_reps):\n",
    "            index = hash_string(hash_fn, word) % self.m\n",
    "            self.bits[index] = True\n",
    "        \n",
    "        \n",
    "    # Check if a word belongs to the Bloom Filter\n",
    "    def member(self, word):\n",
    "        return all(x == True for x in [self.bits[hash_string(hash_fn, word) % self.m] for i, hash_fn in enumerate(self.hash_fun_reps)])\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "3e6d8bde939a16edca749ffe1098aa91",
     "grade": false,
     "grade_id": "cell-92fcbb197bfe3661",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Exact common word count = 124595\n"
     ]
    }
   ],
   "source": [
    "#do the exact count\n",
    "# it is a measure of how optimized python data structures are under the hood that\n",
    "# this operation finishes very quickly.\n",
    "all_words_gg = set(longer_words_gg)\n",
    "exact_common_wc = 0\n",
    "for word in longer_words_wp:\n",
    "    if word in all_words_gg:\n",
    "        exact_common_wc = exact_common_wc + 1\n",
    "print(f'Exact common word count = {exact_common_wc}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "code",
     "checksum": "350ca6a04e5883ce24905f0268d0fc12",
     "grade": true,
     "grade_id": "cell-c43547e8c520ff88",
     "locked": true,
     "points": 10,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of common words of length >= 5 equals : 125134\n",
      "All Tests Passed: 10 points\n"
     ]
    }
   ],
   "source": [
    "# Try to use the same using a bloom filter.\n",
    "bf = BloomFilter(100000, 5)\n",
    "for word in longer_words_gg:\n",
    "    bf.insert(word)\n",
    "    \n",
    "for word in longer_words_gg:\n",
    "    assert (bf.member(word)), f'Word: {word} should be a member'\n",
    "\n",
    "common_word_count = 0\n",
    "for word in longer_words_wp:\n",
    "    if bf.member(word):\n",
    "        common_word_count= common_word_count + 1\n",
    "print(f'Number of common words of length >= 5 equals : {common_word_count}')\n",
    "assert ( common_word_count >= exact_common_wc)\n",
    "print('All Tests Passed: 10 points')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "a058c200be3f1999b4e8b74116969230",
     "grade": false,
     "grade_id": "cell-686a6bc365e25c35",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## Problem 2 B\n",
    "\n",
    "Given a Bloom filter with $m = 100000$ bits and $k = 5$ hash functions that  map each key uniformly at random to one of the bits (assumption), estimate the probability that $k$ bits $i_1, \\ldots, i_k$ are simultaneously set when $n = 10000$ words are inserted. Assume that whether or not a particular bit is set is independent of another."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "6d5522eb5b7340b3e1613d6842b41160",
     "grade": true,
     "grade_id": "cell-be6d976534e0936c",
     "locked": false,
     "points": 0,
     "schema_version": 3,
     "solution": true,
     "task": false
    }
   },
   "source": [
    "YOUR ANSWER HERE"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "e6e2a9b8a817910a9895a3b1ac2adefe",
     "grade": false,
     "grade_id": "cell-80241300e0a5159c",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## Manually Graded Solutions\n",
    "\n",
    "### Problem 1 B \n",
    "\n",
    "\n",
    "Note that for each word we have $\\mathbb{E}( \\text{approxCount}(word) - \\text{count}(word)) \\leq \\frac{N}{m}$.\n",
    "The probability that for some word, the approximate count differs from the real one by at least $80$ for one of the counter banks is bounded by Markov Inequality as:  \n",
    "$$ \\mathbb{P}( \\text{approxCount}(word) - \\text{count}(word) \\geq 80) \\leq \\frac{\\mathbb{E}(\\text{approxCount}(word) - \\text{count}(word))}{80} \\leq \\frac{2.5\\times 10^5}{80 \\times 5000} \\approx \\frac{5}{8} $$.\n",
    "\n",
    "The probability that this happens for all five counter banks is bounded by $\\left(\\frac{5}{8}\\right)^5 \\approx 0.095$.\n",
    "\n",
    "\n",
    "However, this bound happens to be not so tight. Empirically, we see that this happens for roughly one word out of the nearly quarter million words in the corpus.\n",
    "\n",
    "### Problem 2 B\n",
    "\n",
    "The probability that any given bit is not set when $n$ words are inserted is \n",
    "$(1 - \\frac{1}{m})^{kn} = (1 - \\frac{1}{100000})^{5\\times 10000} = e^{-0.5}$.\n",
    "\n",
    "The probability that all five bits are simultaneously set is $(1-e^{-2})^5 = 0.09$.\n",
    "\n",
    "Therefore, we will expect the false positive rate to be roughly $10\\%$.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "cell_type": "markdown",
     "checksum": "21327ec3f51109e1a65a2b7541dd1139",
     "grade": false,
     "grade_id": "cell-e24134f3086d63a4",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    }
   },
   "source": [
    "## That's All Folks!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
